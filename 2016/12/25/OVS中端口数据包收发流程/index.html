<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="LinuxKernel,Linux,OVS," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="今天在网上看到一篇文章《谈谈OpenStack中端口在内核中的收发流程》，这篇文章主要谈到了OVS中端口收发包流程，以及为什么OVS端口不能与IPtables相兼容，文章中对一些代码上的细节并没有说明，所以下面基于Linux-3.19版本内核对此篇文章的整理与补充，并添加了一些自己的理解。">
<meta property="og:type" content="article">
<meta property="og:title" content="OVS中端口数据包收发流程">
<meta property="og:url" content="http://yoursite.com/2016/12/25/OVS中端口数据包收发流程/index.html">
<meta property="og:site_name" content="回忆是一条没有归途的路">
<meta property="og:description" content="今天在网上看到一篇文章《谈谈OpenStack中端口在内核中的收发流程》，这篇文章主要谈到了OVS中端口收发包流程，以及为什么OVS端口不能与IPtables相兼容，文章中对一些代码上的细节并没有说明，所以下面基于Linux-3.19版本内核对此篇文章的整理与补充，并添加了一些自己的理解。">
<meta property="og:updated_time" content="2016-12-25T14:28:40.101Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OVS中端口数据包收发流程">
<meta name="twitter:description" content="今天在网上看到一篇文章《谈谈OpenStack中端口在内核中的收发流程》，这篇文章主要谈到了OVS中端口收发包流程，以及为什么OVS端口不能与IPtables相兼容，文章中对一些代码上的细节并没有说明，所以下面基于Linux-3.19版本内核对此篇文章的整理与补充，并添加了一些自己的理解。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6363975639506093000',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/12/25/OVS中端口数据包收发流程/"/>


  <title> OVS中端口数据包收发流程 | 回忆是一条没有归途的路 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">回忆是一条没有归途的路</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                OVS中端口数据包收发流程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-25T22:13:13+08:00" content="2016-12-25">
              2016-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OVS/" itemprop="url" rel="index">
                    <span itemprop="name">OVS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/25/OVS中端口数据包收发流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/25/OVS中端口数据包收发流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>今天在网上看到一篇文章《<a href="http://blog.chinaunix.net/uid-15035748-id-5379887.html" target="_blank" rel="external">谈谈OpenStack中端口在内核中的收发流程</a>》，这篇文章主要谈到了OVS中端口收发包流程，以及为什么OVS端口不能与IPtables相兼容，文章中对一些代码上的细节并没有说明，所以下面基于Linux-3.19版本内核对此篇文章的整理与补充，并添加了一些自己的理解。</p>
<a id="more"></a>
<h2 id="OpenvSwitch"><a href="#OpenvSwitch" class="headerlink" title="OpenvSwitch"></a>OpenvSwitch</h2><p><a href="http://openvswitch.org" target="_blank" rel="external">Open vSwitch</a>是一个高质量的、多层虚拟交换机，使用开源<a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="external">Apache2.0</a>许可协议，由Nicira Networks开发，主要实现代码为可移植的C代码。它的目的是让大规模网络自动化可以通过编程扩展,同时仍然支持标准的管理接口和协议（例如NetFlow, sFlow, SPAN, RSPAN, CLI, LACP, 802.1ag）。此外,它被设计位支持跨越多个物理服务器的分布式环境，类似于VMware的vNetwork分布式vswitch或Cisco Nexus 1000 V。Open vSwitch支持多种linux 虚拟化技术，包括Xen/XenServer， KVM和VirtualBox。</p>
<h2 id="OVS上system类型接口收发包"><a href="#OVS上system类型接口收发包" class="headerlink" title="OVS上system类型接口收发包"></a>OVS上system类型接口收发包</h2><p>创建虚拟机时，如果引用宿主机上的OpenvSwitch类型桥接口（非netdev类型datapath），则会在宿主机OVS上创建对应的端口就是TUN/TAP端口，这些端口是通过<code>ip tuntap add</code>命令创建的，在OVS中属于<code>system</code>型（此类型代表此接口为系统本身的，而不是OVS创建的）。</p>
<h3 id="system类型接口接收数据包"><a href="#system类型接口接收数据包" class="headerlink" title="system类型接口接收数据包"></a>system类型接口接收数据包</h3><p>于普通物理网卡类似，这种类型的接口在接收数据包时，报文最终也会到达内核函数<code>__netif_receive_skb_core</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">__netif_receive_skb_core(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">bool</span> pfmemalloc)</div><div class="line">&#123;</div><div class="line">	....</div><div class="line">	rx_handler = rcu_dereference(skb-&gt;dev-&gt;rx_handler);</div><div class="line">	<span class="keyword">if</span> (rx_handler) &#123;</div><div class="line">		<span class="keyword">if</span> (pt_prev) &#123;</div><div class="line">			ret = deliver_skb(skb, pt_prev, orig_dev);</div><div class="line">			pt_prev = <span class="literal">NULL</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">switch</span> (rx_handler(&amp;skb)) &#123;</div><div class="line">		<span class="keyword">case</span> RX_HANDLER_CONSUMED:</div><div class="line">			ret = NET_RX_SUCCESS;</div><div class="line">			<span class="keyword">goto</span> unlock;</div><div class="line">		<span class="keyword">case</span> RX_HANDLER_ANOTHER:</div><div class="line">			<span class="keyword">goto</span> another_round;</div><div class="line">		<span class="keyword">case</span> RX_HANDLER_EXACT:</div><div class="line">			deliver_exact = <span class="literal">true</span>;</div><div class="line">		<span class="keyword">case</span> RX_HANDLER_PASS:</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			BUG();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的<code>__netif_receive_skb_core</code>函数中（省略了 不相关的代码），有一个回调函数<code>rx_handler</code>，所有加入OVS bridge的<code>system</code>类型的接口，都会注册一个回调函数。这个函数通过<code>vport-netdev.c:netdev_create()</code>注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> vport *</span></div><div class="line"><span class="title">netdev_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> vport_parms *parms)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> vport *vport;</div><div class="line">	<span class="keyword">struct</span> netdev_vport *netdev_vport;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="comment">/*分配并初始化vport，并为vport分配私有数据空间，</span></div><div class="line">	*  大小为sizeof(struct netdev_vport),</div><div class="line">	* 可以通过netdev_vport_priv()访问 */</div><div class="line">	vport = ovs_vport_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> netdev_vport),</div><div class="line">				&amp;ovs_netdev_vport_ops, parms);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(vport)) &#123;</div><div class="line">		err = PTR_ERR(vport);</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*访问vport私有数据空间*/</span></div><div class="line">	netdev_vport = netdev_vport_priv(vport);</div><div class="line">	<span class="comment">/*通过名称param-&gt;name查找设备*/</span></div><div class="line">	netdev_vport-&gt;dev = </div><div class="line">		dev_get_by_name(ovs_dp_get_net(vport-&gt;dp), parms-&gt;name);</div><div class="line">	<span class="keyword">if</span> (!netdev_vport-&gt;dev) &#123;</div><div class="line">		err = -ENODEV;</div><div class="line">		<span class="keyword">goto</span> error_free_vport;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*此处创建的接扩设备为tun/tap类型接口，所以：</span></div><div class="line">	* 此设备需要满足以下条件：</div><div class="line">	* 1. 不能是loopback设备</div><div class="line">	* 2. 接口类型必须是ARPHRD_ETHER（Ethernet 10Mbps）</div><div class="line">	* 3. 接口不能是ovs internal类型的接口</div><div class="line">	* 如果出现上述情况则只能退出创建此接口</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> (netdev_vport-&gt;dev-&gt;flags &amp; IFF_LOOPBACK ||</div><div class="line">	    netdev_vport-&gt;dev-&gt;type != ARPHRD_ETHER ||</div><div class="line">	    ovs_is_internal_dev(netdev_vport-&gt;dev)) &#123;</div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">goto</span> error_put;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	rtnl_lock();</div><div class="line">	<span class="comment">/*此处应该是将新创建的接口与ovs-system（通过</span></div><div class="line">	*  ovs-appctl dpctl/show命令此查看）接口关联起来，</div><div class="line">	* 不是很确定，后面会再研究研究代码 */</div><div class="line">	err = netdev_master_upper_dev_link(netdev_vport-&gt;dev,</div><div class="line">					   get_dpdev(vport-&gt;dp));</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">goto</span> error_unlock;</div><div class="line">	<span class="comment">/*注册rx_handler回调函数netdev_fram_hook*/</span></div><div class="line">	err = netdev_rx_handler_register(netdev_vport-&gt;dev, netdev_frame_hook,</div><div class="line">					 vport);</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">goto</span> error_master_upper_dev_unlink;</div><div class="line">	<span class="comment">/*设置接口的混杂模式*/</span></div><div class="line">	dev_set_promiscuity(netdev_vport-&gt;dev, <span class="number">1</span>);</div><div class="line">	netdev_vport-&gt;dev-&gt;priv_flags |= IFF_OVS_DATAPATH;</div><div class="line">	rtnl_unlock();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> vport;</div><div class="line"></div><div class="line">error_master_upper_dev_unlink:</div><div class="line">	netdev_upper_dev_unlink(netdev_vport-&gt;dev, get_dpdev(vport-&gt;dp));</div><div class="line">error_unlock:</div><div class="line">	rtnl_unlock();</div><div class="line">error_put:</div><div class="line">	dev_put(netdev_vport-&gt;dev);</div><div class="line">error_free_vport:</div><div class="line">	ovs_vport_free(vport);</div><div class="line">error:</div><div class="line">	<span class="keyword">return</span> ERR_PTR(err);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *	netdev_rx_handler_register - register receive handler</div><div class="line"> *	@dev: device to register a handler for</div><div class="line"> *	@rx_handler: receive handler to register</div><div class="line"> *	@rx_handler_data: data pointer that is used by rx handler</div><div class="line"> *</div><div class="line"> *	Register a receive handler for a device. This handler will then be</div><div class="line"> *	called from __netif_receive_skb. A negative errno code is returned</div><div class="line"> *	on a failure.</div><div class="line"> *</div><div class="line"> *	The caller must hold the rtnl_mutex.</div><div class="line"> *</div><div class="line"> *	For a general description of rx_handler, see enum rx_handler_result.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">netdev_rx_handler_register</span><span class="params">(<span class="keyword">struct</span> net_device *dev,</span></div><div class="line">			       <span class="keyword">rx_handler_func_t</span> *rx_handler,</div><div class="line">			       <span class="keyword">void</span> *rx_handler_data)</div><div class="line">&#123;</div><div class="line">	ASSERT_RTNL();</div><div class="line">	<span class="comment">/*如果dev-&gt;rx_handler已经存在，则返回错误值*/</span></div><div class="line">	<span class="keyword">if</span> (dev-&gt;rx_handler)</div><div class="line">		<span class="keyword">return</span> -EBUSY;</div><div class="line"></div><div class="line">	<span class="comment">/* Note: rx_handler_data must be set before rx_handler */</span></div><div class="line">	<span class="comment">/*此处rx_handler_data即vport，将vport存储到dev-&gt;rx_handler_data中*/</span></div><div class="line">	rcu_assign_pointer(dev-&gt;rx_handler_data, rx_handler_data);</div><div class="line">	<span class="comment">/*注册rx_handler回调函数到dev-&gt;rx_handler中*/</span></div><div class="line">	rcu_assign_pointer(dev-&gt;rx_handler, rx_handler);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在函数<code>netdev_create</code>中为<code>system</code>类型网卡注册了<code>rx_handler</code>回调函数<code>netdev_frame_hook</code>，并将<code>vport</code>信息保存到了<code>dev-&gt;rx_handler_data</code>中。<code>tun/tap</code>类型接口在接收网络报文时会通过<code>netdev_frame_hook</code>函数处理报文。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Called with rcu_read_lock and bottom-halves disabled. */</span></div><div class="line"><span class="function"><span class="keyword">static</span> rx_handler_result_t</span></div><div class="line"><span class="title">netdev_frame_hook</span><span class="params">(<span class="keyword">struct</span> sk_buff **pskb)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> sk_buff *skb = *pskb;</div><div class="line">	<span class="keyword">struct</span> vport *vport;</div><div class="line">	<span class="comment">/*不处理PACKET_LOOKBACK类型报文，直接放通*/</span></div><div class="line">	<span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))</div><div class="line">		<span class="keyword">return</span> RX_HANDLER_PASS;</div><div class="line">	<span class="comment">/*ovs_netdev_get_vport函数会判断skb-&gt;dev是否是attach到datapath的接口，</span></div><div class="line">	* 如果是则从dev-&gt;rx_handler_data中获取vport信息，如果不是则返回NULL。*/</div><div class="line">	vport = ovs_netdev_get_vport(skb-&gt;dev);</div><div class="line">	<span class="comment">/*接收处理数据包*/</span></div><div class="line">	netdev_port_receive(vport, skb);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> RX_HANDLER_CONSUMED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数<code>netdev_frame_hook</code>从<code>skb-&gt;dev</code>中获取<code>vport</code>信息，并通过<code>netdev_port_receive</code>开始真正的接收数据包。从<code>netdev_frame_hook</code>函数最后可以看到，返回值为<code>RX_HANDLER_CONSUMED</code>，在<code>__netif_receive_skb_core</code>函数中调用<code>rx_handler</code>回调函数处可以看到，当返回值为<code>RX_HANDLER_CONSUMED</code>时，设置<code>ret = NET_RX_SUCCESS</code>并且<code>goto unlock</code>，跳到了函数的结尾处，结束了<code>__netif_receive_skb_core</code>函数。通过此处可以看到，OVS的<code>system</code>类型的接口没有执行<code>ip_rcv</code>或者<code>arp_rcv</code>等函数，所以更加不会执行<code>Netfilter</code>的<code>HOOK</code>函数，因此<code>Iptables</code>下发的规则策略对于OVS中的<code>system</code>类型接口收发数据包不生效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Must be called with rcu_read_lock. */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">netdev_port_receive</span><span class="params">(<span class="keyword">struct</span> vport *vport, <span class="keyword">struct</span> sk_buff *skb)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (unlikely(!vport))</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line"></div><div class="line">	<span class="comment">/* 如果开启了LRO但是未开启GSO，则释放此数据包占用的空间 */</span></div><div class="line">	<span class="keyword">if</span> (unlikely(skb_warn_if_lro(skb)))</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line"></div><div class="line">	<span class="comment">/* Make our own copy of the packet.  Otherwise we will mangle the</span></div><div class="line">	 * packet for anyone who came before us (e.g. tcpdump via AF_PACKET).</div><div class="line">	 */</div><div class="line">	<span class="comment">/*检查skb是否是共享的*/</span></div><div class="line">	skb = skb_share_check(skb, GFP_ATOMIC);</div><div class="line">	<span class="keyword">if</span> (unlikely(!skb))</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="comment">/*将skb数据指针skb-&gt;data移动到L2处，并重新计算skb校验和*/</span></div><div class="line">	skb_push(skb, ETH_HLEN);</div><div class="line">	ovs_skb_postpush_rcsum(skb, skb-&gt;data, ETH_HLEN);</div><div class="line">	<span class="comment">/*将接收到的数据包是送到datapath处理*/</span></div><div class="line">	ovs_vport_receive(vport, skb, <span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">return</span>;</div><div class="line"></div><div class="line">error:</div><div class="line">	kfree_skb(skb);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TSO(TCP Segmentation Offload)，是一种利用网卡对TCP数据包分片，减轻CPU负荷的一种技术，有时也被叫做 LSO (Large segment offload) ，TSO是针对TCP的，UFO是针对UDP的。如果硬件支持TSO功能，同时也需要硬件支持的TCP校验计算和分散/聚集 (Scatter Gather) 功能。<br>GSO(Generic Segmentation Offload)，它比TSO更通用，基本思想就是尽可能的推迟数据分片直至发送到网卡驱动之前，此时会检查网卡是否支持分片功能（如TSO、UFO）,如果支持直接发送到网卡， 如果不支持就进行分片后再发往网卡。这样大数据包只需走一次协议栈，而不是被分割成几个数据包分别走，这就提高了效率。<br>LRO(Large Receive Offload)通过将接收到的多个TCP数据聚合成一个大的数据包，然后传递给网络协议栈处理，以减少上层协议栈处理开销，提高系统接收TCP数据包的能力。<br>在<code>netdev_port_receive</code>函数中<code>skb_warn_if_lro(skb)</code>对LRO是否开启进行了判断，如果开启了LRO则会设置<code>gso_size</code>的值，但是在GSO未开启的情况下不会设置<code>gso_type</code>，所以此时会将数据包释放。</p>
<p>在<code>ovs_vport_receive</code>函数中，会<code>skb</code>中提取<code>key</code>值来匹配OVS下发的流表，<code>key</code>值包括<code>源MAC</code> <code>目的MAC</code> <code>VLAN</code> <code>协议类型</code> <code>源IP</code> <code>目的IP</code> <code>源端口</code> <code>`目的端口</code>等信息。而此时skb-&gt;data指针指向L3层头部，所以在将数据包传递给<code>ovs_vport_receive</code>函数处理之前，需要重新设置<code>skb-&gt;data</code>指针指向L2头部，并且重新计算了skb校验和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *	ovs_vport_receive - pass up received packet to the datapath for processing</div><div class="line"> *</div><div class="line"> * @vport: vport that received the packet</div><div class="line"> * @skb: skb that was received</div><div class="line"> * @tun_key: tunnel (if any) that carried packet</div><div class="line"> *</div><div class="line"> * Must be called with rcu_read_lock.  The packet cannot be shared and</div><div class="line"> * skb-&gt;data should point to the Ethernet header.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">ovs_vport_receive</span><span class="params">(<span class="keyword">struct</span> vport *vport, <span class="keyword">struct</span> sk_buff *skb,</span></div><div class="line">		       <span class="keyword">const</span> <span class="keyword">struct</span> ovs_tunnel_info *tun_info)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> pcpu_sw_netstats *stats;</div><div class="line">	<span class="keyword">struct</span> sw_flow_key key;</div><div class="line">	<span class="keyword">int</span> error;</div><div class="line">	<span class="comment">/*获取vport上的每cpu变量，并更新接收到的数据包数及字节数信息*/</span></div><div class="line">	stats = this_cpu_ptr(vport-&gt;percpu_stats);</div><div class="line">	u64_stats_update_begin(&amp;stats-&gt;syncp);</div><div class="line">	stats-&gt;rx_packets++;</div><div class="line">	stats-&gt;rx_bytes += skb-&gt;len + (vlan_tx_tag_present(skb) ? VLAN_HLEN : <span class="number">0</span>);</div><div class="line">	u64_stats_update_end(&amp;stats-&gt;syncp);</div><div class="line">	<span class="comment">/*将skb上的私有数据转换为struct ovs_skb_cb类型，</span></div><div class="line">	*  并为其赋值，存储vport信息*/</div><div class="line">	OVS_CB(skb)-&gt;input_vport = vport;</div><div class="line">	OVS_CB(skb)-&gt;egress_tun_info = <span class="literal">NULL</span>;</div><div class="line">	<span class="comment">/* Extract flow from 'skb' into 'key'. */</span></div><div class="line">	<span class="comment">/*从skb上提取key值信息并存储在key中*/</span></div><div class="line">	error = ovs_flow_key_extract(tun_info, skb, &amp;key);</div><div class="line">	<span class="keyword">if</span> (unlikely(error)) &#123;</div><div class="line">		kfree_skb(skb);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*根据key值处理数据包*/</span></div><div class="line">	ovs_dp_process_packet(skb, &amp;key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>ovs_vport_receive</code>函数中会调用<code>ovs_flog_key_extract</code>从<code>skb</code>中提取<code>key</code>值，并将<code>key</code>值传递给<code>ovs_dp_process_packet</code>函数，根据<code>key</code>来匹配OVS内核流表并执行相应的<code>Flow action</code>。</p>
<h3 id="system类型接口发送数据包"><a href="#system类型接口发送数据包" class="headerlink" title="system类型接口发送数据包"></a>system类型接口发送数据包</h3><p>当流表动作为<code>OUTPUT</code>时，<code>OUTPUT</code>动作调用<code>do_output()</code>函数，最后调用<code>vport-&gt;ops-&gt;send()</code>回调函数将数据包从指定接口发送出去。如果出接口为<code>system</code>类型接口时，数据包通过<code>netdev_send</code>函数发送数据包，最后调用<code>dev_queue_xmit</code>函数发送数据包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*此函数即为OVS流表output action 发送数据包时的函数*/</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">netdev_send</span><span class="params">(<span class="keyword">struct</span> vport *vport, <span class="keyword">struct</span> sk_buff *skb)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> netdev_vport *netdev_vport = netdev_vport_priv(vport);</div><div class="line">	<span class="keyword">int</span> mtu = netdev_vport-&gt;dev-&gt;mtu;</div><div class="line">	<span class="keyword">int</span> len;</div><div class="line">	<span class="comment">/*如果未开启gso且数据包长度大于MTU，则释放数据包*/</span></div><div class="line">	<span class="keyword">if</span> (unlikely(packet_length(skb) &gt; mtu &amp;&amp; !skb_is_gso(skb))) &#123;</div><div class="line">		net_warn_ratelimited(<span class="string">"%s: dropped over-mtu packet: %d &gt; %d\n"</span>,</div><div class="line">				     netdev_vport-&gt;dev-&gt;name,</div><div class="line">				     packet_length(skb), mtu);</div><div class="line">		<span class="keyword">goto</span> drop;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*设置skb-&gt;dev为output action网口*/</span></div><div class="line">	skb-&gt;dev = netdev_vport-&gt;dev;</div><div class="line">	len = skb-&gt;len;</div><div class="line">	<span class="comment">/*最后调用dev_queue_xmit发送数据包*/</span></div><div class="line">	dev_queue_xmit(skb);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> len;</div><div class="line"></div><div class="line">drop:</div><div class="line">	kfree_skb(skb);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="OVS中internal类型接口收发包"><a href="#OVS中internal类型接口收发包" class="headerlink" title="OVS中internal类型接口收发包"></a>OVS中internal类型接口收发包</h2><p>同一台宿主机上的两个OVS<code>internal</code>类型接口通过二层交换实现数据包的收发过程。</p>
<h3 id="internal类型接口发送数据包"><a href="#internal类型接口发送数据包" class="headerlink" title="internal类型接口发送数据包"></a>internal类型接口发送数据包</h3><p>OVS上的<code>internal</code>发送数据包流程为：dev_queue_xmit()-&gt;<strong>dev_queue_xmit()<br>-&gt;dev_hard_start_xmit()-&gt;xmit_one()-&gt;netdev_start_xmit()-&gt;</strong>netdev_start_xmit()<br>-&gt;ops-&gt;ndo_start_xmit()。其中<code>ndo_start_xmit()</code>回调函数是在<code>internal_dev_create()</code>函数创建<code>internal</code>类型接口时进行赋值的，此处<code>ops-&gt;ndo_start_xmit</code>函数为<code>internal_dev_xmit()</code>，<code>internal</code>类型接口数据包最后通过<code>internal_dev_xmit</code>函数发送。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> vport *</span></div><div class="line"><span class="title">internal_dev_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> vport_parms *parms)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> vport *vport;</div><div class="line">	<span class="keyword">struct</span> netdev_vport *netdev_vport;</div><div class="line">	<span class="keyword">struct</span> internal_dev *internal_dev;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="comment">/*分配vport接口空间*/</span></div><div class="line">	vport = ovs_vport_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> netdev_vport),</div><div class="line">				&amp;ovs_internal_vport_ops, parms);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(vport)) &#123;</div><div class="line">		err = PTR_ERR(vport);</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*将netdev_vport指向vport私有数据空间*/</span></div><div class="line">	netdev_vport = netdev_vport_priv(vport);</div><div class="line">	<span class="comment">/*分配net_device空间，并进行初始化，其中do_setup回调函数用来初始化设备*/</span></div><div class="line">	netdev_vport-&gt;dev = alloc_netdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> internal_dev),</div><div class="line">					 parms-&gt;name, NET_NAME_UNKNOWN,</div><div class="line">					 do_setup);</div><div class="line">	<span class="keyword">if</span> (!netdev_vport-&gt;dev) &#123;</div><div class="line">		err = -ENOMEM;</div><div class="line">		<span class="keyword">goto</span> error_free_vport;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	dev_net_set(netdev_vport-&gt;dev, ovs_dp_get_net(vport-&gt;dp));</div><div class="line">	internal_dev = internal_dev_priv(netdev_vport-&gt;dev);</div><div class="line">	internal_dev-&gt;vport = vport;</div><div class="line"></div><div class="line">	<span class="comment">/* Restrict bridge port to current netns. */</span></div><div class="line">	<span class="keyword">if</span> (vport-&gt;port_no == OVSP_LOCAL)</div><div class="line">		netdev_vport-&gt;dev-&gt;features |= NETIF_F_NETNS_LOCAL;</div><div class="line"></div><div class="line">	rtnl_lock();</div><div class="line">	<span class="comment">/*注册设备*/</span></div><div class="line">	err = register_netdevice(netdev_vport-&gt;dev);</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">goto</span> error_free_netdev;</div><div class="line">	<span class="comment">/*设置混杂模式*/</span></div><div class="line">	dev_set_promiscuity(netdev_vport-&gt;dev, <span class="number">1</span>);</div><div class="line">	rtnl_unlock();</div><div class="line">	<span class="comment">/*设置接口允许传输数据：清除dev-&gt;_tx[0].state</span></div><div class="line">	* 的_QUEUE_STATE_DRV_XOFF标志*/</div><div class="line">	netif_start_queue(netdev_vport-&gt;dev);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> vport;</div><div class="line"></div><div class="line">error_free_netdev:</div><div class="line">	rtnl_unlock();</div><div class="line">	free_netdev(netdev_vport-&gt;dev);</div><div class="line">error_free_vport:</div><div class="line">	ovs_vport_free(vport);</div><div class="line">error:</div><div class="line">	<span class="keyword">return</span> ERR_PTR(err);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*设备管理操作函数结构*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> net_device_ops internal_dev_netdev_ops = &#123;</div><div class="line">	.ndo_open = internal_dev_open,</div><div class="line">	.ndo_stop = internal_dev_stop,</div><div class="line">	.ndo_start_xmit = internal_dev_xmit,</div><div class="line">	.ndo_set_mac_address = eth_mac_addr,</div><div class="line">	.ndo_change_mtu = internal_dev_change_mtu,</div><div class="line">	.ndo_get_stats64 = internal_dev_get_stats,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*internal类型设备初始化函数*/</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">do_setup</span><span class="params">(<span class="keyword">struct</span> net_device *netdev)</span></div><div class="line">&#123;</div><div class="line">	ether_setup(netdev);</div><div class="line">	<span class="comment">/*netdev_ops为设备管理回调函数*/</span></div><div class="line">	netdev-&gt;netdev_ops = &amp;internal_dev_netdev_ops;</div><div class="line"></div><div class="line">	netdev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;</div><div class="line">	netdev-&gt;priv_flags |= IFF_LIVE_ADDR_CHANGE;</div><div class="line">	netdev-&gt;destructor = internal_dev_destructor;</div><div class="line">	netdev-&gt;ethtool_ops = &amp;internal_dev_ethtool_ops;</div><div class="line">	netdev-&gt;rtnl_link_ops = &amp;internal_dev_link_ops;</div><div class="line">	netdev-&gt;tx_queue_len = <span class="number">0</span>;</div><div class="line"></div><div class="line">	netdev-&gt;features = NETIF_F_LLTX | NETIF_F_SG | NETIF_F_FRAGLIST |</div><div class="line">			   NETIF_F_HIGHDMA | NETIF_F_HW_CSUM |</div><div class="line">			   NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_ENCAP_ALL;</div><div class="line"></div><div class="line">	netdev-&gt;vlan_features = netdev-&gt;features;</div><div class="line">	netdev-&gt;hw_enc_features = netdev-&gt;features;</div><div class="line">	netdev-&gt;features |= NETIF_F_HW_VLAN_CTAG_TX;</div><div class="line">	netdev-&gt;hw_features = netdev-&gt;features &amp; ~NETIF_F_LLTX;</div><div class="line"></div><div class="line">	eth_hw_addr_random(netdev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>internal_dev_xmit()</code>函数中，会发现其最终调用<code>ovs_vport_receive()</code>函数。之后从数据包中提取<code>key</code>值，然后匹配流表，执行相应的流表动作。当流表动作为<code>OUTPUT</code>时，通过<code>do_output</code>函数调用<code>vport-&gt;ops-&gt;send()</code>回调函数发送数据包。在<code>internal</code>类型接口中，对应的<code>send</code>函数为<code>internal_dev_recv</code>函数。因为后面还会遇到<code>internal_dev_recv</code>函数，所以后面再对<code>internal_dev_recv</code>函数进行分析。</p>
<h3 id="internal类型接口接收数据包"><a href="#internal类型接口接收数据包" class="headerlink" title="internal类型接口接收数据包"></a>internal类型接口接收数据包</h3><p>OVS上<code>internal</code>类型接口接收数据包流程为：ovs_vport_receive()<br>-&gt;ovs_dp_process_packet()-&gt;ovs_execute_actions()-&gt;do_execute_actions()<br>-&gt;do_output()-&gt;ovs_vport_send()-&gt;vport-&gt;ops-&gt;send()。此处<code>send</code>回调函数为<code>intrnal_dev_recv()</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">internal_dev_recv</span><span class="params">(<span class="keyword">struct</span> vport *vport, <span class="keyword">struct</span> sk_buff *skb)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/*从vport中获取net_device结构*/</span></div><div class="line">	<span class="keyword">struct</span> net_device *netdev = netdev_vport_priv(vport)-&gt;dev;</div><div class="line">	<span class="keyword">int</span> len;</div><div class="line">	<span class="comment">/*如果接口未UP，则释放skb数据并退出*/</span></div><div class="line">	<span class="keyword">if</span> (unlikely(!(netdev-&gt;flags &amp; IFF_UP))) &#123;</div><div class="line">		kfree_skb(skb);</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*获取skb数据包长度*/</span></div><div class="line">	len = skb-&gt;len;</div><div class="line"></div><div class="line">	skb_dst_drop(skb);</div><div class="line">	nf_reset(skb);</div><div class="line">	secpath_reset(skb);</div><div class="line">	<span class="comment">/*将skb-&gt;dev修改为本接口的vport获取的net_device相关信息*/</span></div><div class="line">	skb-&gt;dev = netdev;</div><div class="line">	<span class="comment">/*设置skb-&gt;pkt_type类型为本机接收数据包类型*/</span></div><div class="line">	skb-&gt;pkt_type = PACKET_HOST;</div><div class="line">	<span class="comment">/*获取数据包类型，然后重新pull数据包ETH_HLEN字节并重新计算校验和*/</span></div><div class="line">	skb-&gt;protocol = eth_type_trans(skb, netdev);</div><div class="line">	skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);</div><div class="line">	<span class="comment">/*调用netif_rx接收数据包*/</span></div><div class="line">	netif_rx(skb);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对OVS上<code>internal</code>类型接口收发数据包分析可以知道，同一宿主机上的两个<code>internal</code>类型接口，一个接口发送数据包时，调用的发送接口<code>internal_dev_recv</code>函数即为另外一个接口的数据包接收函数，通过这种数据包交换完成<code>internal</code>类型两个接口的发送接收的交互过程，其实就是在执行OVS的流表匹配及执行流表的工作过程。</p>
<h2 id="OVS中VXLAN接口收发数据包"><a href="#OVS中VXLAN接口收发数据包" class="headerlink" title="OVS中VXLAN接口收发数据包"></a>OVS中VXLAN接口收发数据包</h2><p>VXLAN(virtual Extensible LAN)虚拟可扩展局域网，是一种overlay的网络技术，使用MAC in UDP的方法进行封装，共50字节的封装报文头。具体报文格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 完整数据包格式</div><div class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line">|MAC header| IP header | UDP Header | Vxlan Header | Orig L2 Frame | FCS|</div><div class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</div><div class="line"></div><div class="line"># Vxlan Header</div><div class="line">+++++++++++++++++++++++++++++++++++++++</div><div class="line">| Flags | Reserved1 | VNI | Reserved2 |</div><div class="line">+++++++++++++++++++++++++++++++++++++++</div><div class="line"># Flag： 8bit</div><div class="line"># Reserved1：24bit</div><div class="line"># VNI(Vxlan Network identifier): 24bit</div><div class="line"># Reserved2: 8bit</div></pre></td></tr></table></figure>
<ul>
<li>Vxlan Header<br>共计8个字节，目前使用的是Flags中的8bit的标示位和24bit的VNI(Vxlan Network Identifier)，其余部分没有定义，但是在使用时必须设置为0x0000</li>
<li>外层UDP Header<br>目的端口使用4798，可以根据需要进行修改。UDP的校验和必须设置为全0</li>
<li>外层IP Header：<br>目的IP地址可以是单播地址，也可以是多播地址。单播情况下，目的IP地址是VTEP(Vxlan Tunnel End Point)的IP地址。在多播情况下引入VXLAN管理层，利用VNI和IP多播组的映射来确定VTEPs。</li>
<li>外层MAC Header<br>VLAN：Vlan Type被设置为0x8100，并可以设置Vlan Id tag（这就是vxlan的vlan标签）<br>Ethertype：设置为0x0800，指明数据包为IPv4类型</li>
</ul>
<p>VTEP(Vxlan Tunnel End Point)：用于对VXLAN报文进行封装/解封装，包括ARP请求报文和正常的VXLAN数据报文，在一段封装报文后通过隧道向另一端VTEP发送封装报文，另一端VTEP接收到封装的报文解封装后根据封装的MAC地址进行装法。VTEP可由支持VXLAN的硬件设备或软件来实现。</p>
<p>从封装的结构上来看，VXLAN提供了将二层网络overlay在三层网络上的能力，VXLAN Header中的VNI有24个bit，数量远远大于4096，并且UDP的封装可以穿越三层网络，比VLAN有更好的扩展性。</p>
<p>在OVS中，无论添加多少个<code>vxlan</code>类型接口，在<code>ovs-dpctl show</code>命令下，只能看到一个<code>vxlan_sys_4789</code>名称的接口，之所以这样是因为Vxlan使用的是UDP Socket。Vxlan是建立在UDP之上的一种隧道，默认的目的端口就是4789。当我们通过<code>ovs-vsctl</code>增加一个<code>vxlan</code>类型的接口时，内核中调用<code>vport-vxlan.c:vxlan_tnl_create()</code>函数，创建UDP Socket。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> vport *</span></div><div class="line"><span class="title">vxlan_tnl_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> vport_parms *parms)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> net *net = ovs_dp_get_net(parms-&gt;dp);</div><div class="line">	<span class="keyword">struct</span> nlattr *options = parms-&gt;options;</div><div class="line">	<span class="keyword">struct</span> vxlan_port *vxlan_port;</div><div class="line">	<span class="keyword">struct</span> vxlan_sock *vs;</div><div class="line">	<span class="keyword">struct</span> vport *vport;</div><div class="line">	<span class="keyword">struct</span> nlattr *a;</div><div class="line">	u16 dst_port;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!options) &#123;</div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*从参数中获取vxlan封装的UDP消息的目的端口dst_port*/</span></div><div class="line">	a = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);</div><div class="line">	<span class="keyword">if</span> (a &amp;&amp; nla_len(a) == <span class="keyword">sizeof</span>(u16)) &#123;</div><div class="line">		dst_port = nla_get_u16(a);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">/* Require destination port from userspace. */</span></div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*分配vport空间，并进行初始化*/</span></div><div class="line">	vport = ovs_vport_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vxlan_port),</div><div class="line">				&amp;ovs_vxlan_vport_ops, parms);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(vport))</div><div class="line">		<span class="keyword">return</span> vport;</div><div class="line">	<span class="comment">/*获取vxlan接口私有数据空间，并为vxlan_port接口名称赋值*/</span></div><div class="line">	vxlan_port = vxlan_vport(vport);</div><div class="line">	<span class="built_in">strncpy</span>(vxlan_port-&gt;name, parms-&gt;name, IFNAMSIZ);</div><div class="line">	<span class="comment">/*创建vxlan sock并绑定数据包接收回到函数vxlan_rcv*/</span></div><div class="line">	vs = vxlan_sock_add(net, htons(dst_port), vxlan_rcv, vport, <span class="literal">true</span>, <span class="number">0</span>);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(vs)) &#123;</div><div class="line">		ovs_vport_free(vport);</div><div class="line">		<span class="keyword">return</span> (<span class="keyword">void</span> *)vs;</div><div class="line">	&#125;</div><div class="line">	vxlan_port-&gt;vs = vs;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> vport;</div><div class="line"></div><div class="line">error:</div><div class="line">	<span class="keyword">return</span> ERR_PTR(err);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*vxlan接口socket创建函数</span></div><div class="line">* rcv: vxlan_rcv</div><div class="line">* data: vport</div><div class="line">* no_share: true</div><div class="line">* flags: 0</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">struct</span> vxlan_sock *</span></div><div class="line"><span class="title">vxlan_sock_add</span><span class="params">(<span class="keyword">struct</span> net *net, __be16 port,</span></div><div class="line">				  <span class="keyword">vxlan_rcv_t</span> *rcv, <span class="keyword">void</span> *data,</div><div class="line">				  <span class="keyword">bool</span> no_share, u32 flags)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> vxlan_net *vn = net_generic(net, vxlan_net_id);</div><div class="line">	<span class="keyword">struct</span> vxlan_sock *vs;</div><div class="line">	<span class="keyword">bool</span> ipv6 = flags &amp; VXLAN_F_IPV6;</div><div class="line">	<span class="comment">/*真正的创建vxlan soecket的函数*/</span></div><div class="line">	vs = vxlan_socket_create(net, port, rcv, data, flags);</div><div class="line">	<span class="keyword">if</span> (!IS_ERR(vs))</div><div class="line">		<span class="keyword">return</span> vs;</div><div class="line">	<span class="comment">/*此处no_share为true，直接返回*/</span></div><div class="line">	<span class="keyword">if</span> (no_share)	<span class="comment">/* Return error if sharing is not allowed. */</span></div><div class="line">		<span class="keyword">return</span> vs;</div><div class="line"></div><div class="line">	spin_lock(&amp;vn-&gt;sock_lock);</div><div class="line">	vs = vxlan_find_sock(net, ipv6 ? AF_INET6 : AF_INET, port);</div><div class="line">	<span class="keyword">if</span> (vs &amp;&amp; ((vs-&gt;rcv != rcv) ||</div><div class="line">		   !atomic_add_unless(&amp;vs-&gt;refcnt, <span class="number">1</span>, <span class="number">0</span>)))</div><div class="line">			vs = ERR_PTR(-EBUSY);</div><div class="line">	spin_unlock(&amp;vn-&gt;sock_lock);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!vs)</div><div class="line">		vs = ERR_PTR(-EINVAL);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> vs;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* rcv: vxlan_rcv</div><div class="line">* data: vport</div><div class="line">* flags: 0</div><div class="line">*/</div><div class="line"><span class="comment">/* Create new listen socket if needed */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> vxlan_sock *</span></div><div class="line"><span class="title">vxlan_socket_create</span><span class="params">(<span class="keyword">struct</span> net *net, __be16 port,</span></div><div class="line">					      <span class="keyword">vxlan_rcv_t</span> *rcv, <span class="keyword">void</span> *data,</div><div class="line">					      u32 flags)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> vxlan_net *vn = net_generic(net, vxlan_net_id);</div><div class="line">	<span class="keyword">struct</span> vxlan_sock *vs;</div><div class="line">	<span class="keyword">struct</span> socket *sock;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line">	<span class="keyword">bool</span> ipv6 = !!(flags &amp; VXLAN_F_IPV6);</div><div class="line">	<span class="keyword">struct</span> udp_tunnel_sock_cfg tunnel_cfg;</div><div class="line">	<span class="comment">/*为vxlan_sock结构分配空间*/</span></div><div class="line">	vs = kzalloc(<span class="keyword">sizeof</span>(*vs), GFP_KERNEL);</div><div class="line">	<span class="keyword">if</span> (!vs)</div><div class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (h = <span class="number">0</span>; h &lt; VNI_HASH_SIZE; ++h)</div><div class="line">		INIT_HLIST_HEAD(&amp;vs-&gt;vni_list[h]);</div><div class="line"></div><div class="line">	INIT_WORK(&amp;vs-&gt;del_work, vxlan_del_work);</div><div class="line">	<span class="comment">/*创建vxlan socket，此处ipv6为0，flags为0*/</span></div><div class="line">	sock = vxlan_create_sock(net, ipv6, port, flags);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(sock)) &#123;</div><div class="line">		kfree(vs);</div><div class="line">		<span class="keyword">return</span> ERR_CAST(sock);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*将创建的sock与vs-&gt;sock关联*/</span></div><div class="line">	vs-&gt;sock = sock;</div><div class="line">	<span class="comment">/*设置vxlan sock引用计数为1*/</span></div><div class="line">	atomic_set(&amp;vs-&gt;refcnt, <span class="number">1</span>);</div><div class="line">	<span class="comment">/*设置vs-&gt;rcv为vxlan_rcv*/</span></div><div class="line">	vs-&gt;rcv = rcv;</div><div class="line">	<span class="comment">/*设置vs-&gt;data为vport */</span></div><div class="line">	vs-&gt;data = data;</div><div class="line"></div><div class="line">	<span class="comment">/* Initialize the vxlan udp offloads structure */</span></div><div class="line">	vs-&gt;udp_offloads.port = port;</div><div class="line">	vs-&gt;udp_offloads.callbacks.gro_receive  = vxlan_gro_receive;</div><div class="line">	vs-&gt;udp_offloads.callbacks.gro_complete = vxlan_gro_complete;</div><div class="line">	</div><div class="line">	spin_lock(&amp;vn-&gt;sock_lock);</div><div class="line">	<span class="comment">/*将vxlan sock挂到vxlan的sock链表上，以端口号port为hash值*/</span></div><div class="line">	hlist_add_head_rcu(&amp;vs-&gt;hlist, vs_head(net, port));</div><div class="line">	<span class="comment">/*通知设备vxlan sock已经开始监听*/</span></div><div class="line">	vxlan_notify_add_rx_port(vs);</div><div class="line">	spin_unlock(&amp;vn-&gt;sock_lock);</div><div class="line"></div><div class="line">	<span class="comment">/* Mark socket as an encapsulation socket. */</span></div><div class="line">	<span class="comment">/*vxlan是一种封装在UDP的隧道技术，所以此处需要标识sock为封装socekt*/</span></div><div class="line">	tunnel_cfg.sk_user_data = vs;</div><div class="line">	tunnel_cfg.encap_type = <span class="number">1</span>;</div><div class="line">	<span class="comment">/*隧道封装接收函数赋值为vxlan_udp_encap_recv，</span></div><div class="line">	* 后面接收数据包时会用到此函数*/</div><div class="line">	tunnel_cfg.encap_rcv = vxlan_udp_encap_recv;</div><div class="line">	tunnel_cfg.encap_destroy = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	setup_udp_tunnel_sock(net, sock, &amp;tunnel_cfg);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> vs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在添加<code>vxlan</code>类型接口时，通过<code>vxlan_tnl_create()</code>函数添加了<code>vxlan sock</code>并为其关联了数据包接收函数<code>vxlan_rcv</code>，同时还将<code>vxlan scok</code>标识为隧道封装socket，设置了隧道封装接收函数<code>vxlan_udp_encap_recv()</code>。</p>
<h3 id="vxlan类型接口接收数据包"><a href="#vxlan类型接口接收数据包" class="headerlink" title="vxlan类型接口接收数据包"></a>vxlan类型接口接收数据包</h3><p>OVS上<code>vxlan</code>类型接收接数据包流程：<strong>netif_receive_skb_core()-&gt;ip_rcv()<br>-&gt;udp_rcv()-&gt;</strong>udp4_lib_rcv()-&gt;udp_queue_rcv_skb()-&gt;vxlan_udp_encap_recv。数据包接收前半段跟普通UDP数据包接收相同，主要不同在于<code>udp_queue_rcv_skb()</code>函数，会判断UDP数据包是否是一个隧道封装报文，如果是则调用相关的隧道封装接收函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">udp_queue_rcv_skb</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> udp_sock *up = udp_sk(sk);</div><div class="line">	<span class="keyword">int</span> rc;</div><div class="line">	<span class="keyword">int</span> is_udplite = IS_UDPLITE(sk);</div><div class="line"></div><div class="line">	......</div><div class="line">	<span class="comment">/*判断udp sock是否是隧道封装格式*/</span></div><div class="line">	<span class="keyword">if</span> (static_key_false(&amp;udp_encap_needed) &amp;&amp; up-&gt;encap_type) &#123;</div><div class="line">		<span class="keyword">int</span> (*encap_rcv)(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb);</div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * This is an encapsulation socket so pass the skb to</div><div class="line">		 * the socket's udp_encap_rcv() hook. Otherwise, just</div><div class="line">		 * fall through and pass this up the UDP socket.</div><div class="line">		 * up-&gt;encap_rcv() returns the following value:</div><div class="line">		 * =0 if skb was successfully passed to the encap</div><div class="line">		 *    handler or was discarded by it.</div><div class="line">		 * &gt;0 if skb should be passed on to UDP.</div><div class="line">		 * &lt;0 if skb should be resubmitted as proto -N</div><div class="line">		 */</div><div class="line"></div><div class="line">		<span class="comment">/* if we're overly short, let UDP handle it */</span></div><div class="line">		<span class="comment">/*获取隧道封装报文接收函数，此处为vxlan_udp_encap_recv()函数*/</span></div><div class="line">		encap_rcv = ACCESS_ONCE(up-&gt;encap_rcv);</div><div class="line">		<span class="keyword">if</span> (skb-&gt;len &gt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udphdr) &amp;&amp; encap_rcv != <span class="literal">NULL</span>) &#123;</div><div class="line">			<span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">			<span class="comment">/* Verify checksum before giving to encap */</span></div><div class="line">			<span class="keyword">if</span> (udp_lib_checksum_complete(skb))</div><div class="line">				<span class="keyword">goto</span> csum_error;</div><div class="line">			<span class="comment">/*调用vxlan_udp_encap_recv()函数处理报文*/</span></div><div class="line">			ret = encap_rcv(sk, skb);</div><div class="line">			<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</div><div class="line">				UDP_INC_STATS_BH(sock_net(sk),</div><div class="line">						 UDP_MIB_INDATAGRAMS,</div><div class="line">						 is_udplite);</div><div class="line">				<span class="keyword">return</span> -ret;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* FALLTHROUGH -- it's a UDP Packet */</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的<code>udp_queue_rcv_skb()</code>函数中调用<code>encap_rcv()</code>函数即<code>vxlan_udp_encap_recv()</code>函数处理报文：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Callback from net/ipv4/udp.c to receive packets */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">vxlan_udp_encap_recv</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> vxlan_sock *vs;</div><div class="line">	<span class="keyword">struct</span> vxlanhdr *vxh;</div><div class="line"></div><div class="line">	<span class="comment">/* Need Vxlan and inner Ethernet header to be present */</span></div><div class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, VXLAN_HLEN))</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line"></div><div class="line">	<span class="comment">/* Return packets with reserved bits set */</span></div><div class="line">	<span class="comment">/*获取vxlan协议vxlan报文头部*/</span></div><div class="line">	vxh = (<span class="keyword">struct</span> vxlanhdr *)(udp_hdr(skb) + <span class="number">1</span>);</div><div class="line">	<span class="comment">/*判断vxlan消息头部信息是否正确*/</span></div><div class="line">	<span class="keyword">if</span> (vxh-&gt;vx_flags != htonl(VXLAN_FLAGS) ||</div><div class="line">	    (vxh-&gt;vx_vni &amp; htonl(<span class="number">0xff</span>))) &#123;</div><div class="line">		netdev_dbg(skb-&gt;dev, <span class="string">"invalid vxlan flags=%#x vni=%#x\n"</span>,</div><div class="line">			   ntohl(vxh-&gt;vx_flags), ntohl(vxh-&gt;vx_vni));</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*去掉vxlan封装外部UDP头及vxlan头部*/</span></div><div class="line">	<span class="keyword">if</span> (iptunnel_pull_header(skb, VXLAN_HLEN, htons(ETH_P_TEB)))</div><div class="line">		<span class="keyword">goto</span> drop;</div><div class="line">	<span class="comment">/*获取vxlan sock*/</span></div><div class="line">	vs = rcu_dereference_sk_user_data(sk);</div><div class="line">	<span class="keyword">if</span> (!vs)</div><div class="line">		<span class="keyword">goto</span> drop;</div><div class="line">	<span class="comment">/*此处vs-&gt;rcv及vxlan_rcv()函数*/</span></div><div class="line">	vs-&gt;rcv(vs, skb, vxh-&gt;vx_vni);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">drop:</div><div class="line">	<span class="comment">/* Consume bad packet */</span></div><div class="line">	kfree_skb(skb);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">error:</div><div class="line">	<span class="comment">/* Return non vxlan pkt */</span></div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用<code>vxlan_rcv()</code>函数接收数据包：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Called with rcu_read_lock and BH disabled. */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">vxlan_rcv</span><span class="params">(<span class="keyword">struct</span> vxlan_sock *vs, <span class="keyword">struct</span> sk_buff *skb, __be32 vx_vni)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> ovs_tunnel_info tun_info;</div><div class="line">	<span class="keyword">struct</span> vport *vport = vs-&gt;data;</div><div class="line">	<span class="keyword">struct</span> iphdr *iph;</div><div class="line">	__be64 key;</div><div class="line"></div><div class="line">	<span class="comment">/* Save outer tunnel values */</span></div><div class="line">	<span class="comment">/*获取IP头部，IP头部信息保存了外部封装的源地址及目的地址等信息*/</span></div><div class="line">	iph = ip_hdr(skb);</div><div class="line">	<span class="comment">/*获取vxlan的VNI信息*/</span></div><div class="line">	key = cpu_to_be64(ntohl(vx_vni) &gt;&gt; <span class="number">8</span>);</div><div class="line">	<span class="comment">/*将外部封装的IP信息及UDP信息，vxlan信息赋值到</span></div><div class="line">	* ovs_tunnel_info隧道信息存储结构中 */</div><div class="line">	ovs_flow_tun_info_init(&amp;tun_info, iph,</div><div class="line">			       udp_hdr(skb)-&gt;source, udp_hdr(skb)-&gt;dest,</div><div class="line">			       key, TUNNEL_KEY, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">	<span class="comment">/*调用ovs_vport_receive()函数，进行flow math及execute actions*/</span></div><div class="line">	ovs_vport_receive(vport, skb, &amp;tun_info);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>vxlan_rcv()</code>函数中存储<code>vxlan</code>封装信息，并将封装信息传递给<code>ovs_vport_receive()</code>函数，进行<code>flow match</code>及<code>execute actions</code>操作。</p>
<h3 id="vxlan类型接口发送数据包"><a href="#vxlan类型接口发送数据包" class="headerlink" title="vxlan类型接口发送数据包"></a>vxlan类型接口发送数据包</h3><p>当OVS数据包出接口为<code>vxlan</code>类型接口时，通过<code>do_output()</code>调用的<code>vport-&gt;ops-&gt;send()</code>回调函数对应的函数为<code>vxlan_tnl_send()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">vxlan_tnl_send</span><span class="params">(<span class="keyword">struct</span> vport *vport, <span class="keyword">struct</span> sk_buff *skb)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> net *net = ovs_dp_get_net(vport-&gt;dp);</div><div class="line">	<span class="keyword">struct</span> vxlan_port *vxlan_port = vxlan_vport(vport);</div><div class="line">	__be16 dst_port = inet_sk(vxlan_port-&gt;vs-&gt;sock-&gt;sk)-&gt;inet_sport;</div><div class="line">	<span class="keyword">struct</span> ovs_key_ipv4_tunnel *tun_key;</div><div class="line">	<span class="keyword">struct</span> rtable *rt;</div><div class="line">	<span class="keyword">struct</span> flowi4 fl;</div><div class="line">	__be16 src_port;</div><div class="line">	__be16 df;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (unlikely(!OVS_CB(skb)-&gt;egress_tun_info)) &#123;</div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*获取外部封装信息：srcaddr/dstaddr/protocol等*/</span></div><div class="line">	tun_key = &amp;OVS_CB(skb)-&gt;egress_tun_info-&gt;tunnel;</div><div class="line">	<span class="comment">/* Route lookup */</span></div><div class="line">	<span class="built_in">memset</span>(&amp;fl, <span class="number">0</span>, <span class="keyword">sizeof</span>(fl));</div><div class="line">	fl.daddr = tun_key-&gt;ipv4_dst;</div><div class="line">	fl.saddr = tun_key-&gt;ipv4_src;</div><div class="line">	fl.flowi4_tos = RT_TOS(tun_key-&gt;ipv4_tos);</div><div class="line">	fl.flowi4_mark = skb-&gt;mark;</div><div class="line">	fl.flowi4_proto = IPPROTO_UDP;</div><div class="line">	<span class="comment">/*根据获取到的外部封装IP信息查询路由表*/</span></div><div class="line">	rt = ip_route_output_key(net, &amp;fl);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(rt)) &#123;</div><div class="line">		err = PTR_ERR(rt);</div><div class="line">		<span class="keyword">goto</span> error;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*获取数据包是否分片标识*/</span></div><div class="line">	df = tun_key-&gt;tun_flags &amp; TUNNEL_DONT_FRAGMENT ?</div><div class="line">		htons(IP_DF) : <span class="number">0</span>;</div><div class="line"></div><div class="line">	skb-&gt;ignore_df = <span class="number">1</span>;</div><div class="line">	<span class="comment">/*获取外部封装数据包源端口信息*/</span></div><div class="line">	src_port = udp_flow_src_port(net, skb, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</div><div class="line">	<span class="comment">/*调用vxlan_xmit_skb发送数据包*/</span></div><div class="line">	err = vxlan_xmit_skb(vxlan_port-&gt;vs, rt, skb,</div><div class="line">			     fl.saddr, tun_key-&gt;ipv4_dst,</div><div class="line">			     tun_key-&gt;ipv4_tos, tun_key-&gt;ipv4_ttl, df,</div><div class="line">			     src_port, dst_port,</div><div class="line">			     htonl(be64_to_cpu(tun_key-&gt;tun_id) &lt;&lt; <span class="number">8</span>),</div><div class="line">			     <span class="literal">false</span>);</div><div class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">		ip_rt_put(rt);</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">error:</div><div class="line">	kfree_skb(skb);</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> </span></div><div class="line"><span class="title">vxlan_xmit_skb</span><span class="params">(<span class="keyword">struct</span> vxlan_sock *vs,</span></div><div class="line">		   <span class="keyword">struct</span> rtable *rt, <span class="keyword">struct</span> sk_buff *skb,</div><div class="line">		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,</div><div class="line">		   __be16 src_port, __be16 dst_port, __be32 vni, <span class="keyword">bool</span> xnet)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> vxlanhdr *vxh;</div><div class="line">	<span class="keyword">int</span> min_headroom;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">bool</span> udp_sum = !vs-&gt;sock-&gt;sk-&gt;sk_no_check_tx;</div><div class="line"></div><div class="line">	skb = udp_tunnel_handle_offloads(skb, udp_sum);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(skb))</div><div class="line">		<span class="keyword">return</span> PTR_ERR(skb);</div><div class="line">	<span class="comment">/*获取最小包头长度*/</span></div><div class="line">	min_headroom = LL_RESERVED_SPACE(rt-&gt;dst.dev) + rt-&gt;dst.header_len</div><div class="line">			+ VXLAN_HLEN + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr)</div><div class="line">			+ (vlan_tx_tag_present(skb) ? VLAN_HLEN : <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">/* Need space for new headers (invalidates iph ptr) */</span></div><div class="line">	<span class="comment">/*扩展skb头部，使之能够容纳vxlan外层封装头部*/</span></div><div class="line">	err = skb_cow_head(skb, min_headroom);</div><div class="line">	<span class="keyword">if</span> (unlikely(err)) &#123;</div><div class="line">		kfree_skb(skb);</div><div class="line">		<span class="keyword">return</span> err;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*设置vlan tag到skb中*/</span></div><div class="line">	skb = vlan_hwaccel_push_inside(skb);</div><div class="line">	<span class="keyword">if</span> (WARN_ON(!skb))</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line">	<span class="comment">/*添加vxlan头部信息*/</span></div><div class="line">	vxh = (<span class="keyword">struct</span> vxlanhdr *) __skb_push(skb, <span class="keyword">sizeof</span>(*vxh));</div><div class="line">	vxh-&gt;vx_flags = htonl(VXLAN_FLAGS);</div><div class="line">	vxh-&gt;vx_vni = vni;</div><div class="line">	<span class="comment">/*设置skb内部封装协议*/</span></div><div class="line">	skb_set_inner_protocol(skb, htons(ETH_P_TEB));</div><div class="line"></div><div class="line">	<span class="keyword">return</span> udp_tunnel_xmit_skb(vs-&gt;sock, rt, skb, src, dst, tos,</div><div class="line">				   ttl, df, src_port, dst_port, xnet);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*为数据包添加UDP封装头部*/</span></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">udp_tunnel_xmit_skb</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> rtable *rt,</span></div><div class="line">			<span class="keyword">struct</span> sk_buff *skb, __be32 src, __be32 dst,</div><div class="line">			__u8 tos, __u8 ttl, __be16 df, __be16 src_port,</div><div class="line">			__be16 dst_port, <span class="keyword">bool</span> xnet)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> udphdr *uh;</div><div class="line">	<span class="comment">/*添加UDP报文头部*/</span></div><div class="line">	__skb_push(skb, <span class="keyword">sizeof</span>(*uh));</div><div class="line">	skb_reset_transport_header(skb);</div><div class="line">	uh = udp_hdr(skb);</div><div class="line"></div><div class="line">	uh-&gt;dest = dst_port;</div><div class="line">	uh-&gt;source = src_port;</div><div class="line">	uh-&gt;len = htons(skb-&gt;len);</div><div class="line">	<span class="comment">/*为UDP封装数据包设置校验和信息*/</span></div><div class="line">	udp_set_csum(sock-&gt;sk-&gt;sk_no_check_tx, skb, src, dst, skb-&gt;len);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> iptunnel_xmit(sock-&gt;sk, rt, skb, src, dst, IPPROTO_UDP,</div><div class="line">			     tos, ttl, df, xnet);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*为数据包添加IP封装头部信息*/</span></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">iptunnel_xmit</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> rtable *rt, <span class="keyword">struct</span> sk_buff *skb,</span></div><div class="line">		  __be32 src, __be32 dst, __u8 proto,</div><div class="line">		  __u8 tos, __u8 ttl, __be16 df, <span class="keyword">bool</span> xnet)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> pkt_len = skb-&gt;len;</div><div class="line">	<span class="keyword">struct</span> iphdr *iph;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="comment">/*封装IP包头前，清除数据包上的一些信息*/</span></div><div class="line">	skb_scrub_packet(skb, xnet);</div><div class="line">	<span class="comment">/*清空skb的hash*/</span></div><div class="line">	skb_clear_hash(skb);</div><div class="line">	<span class="comment">/*设置路由信息*/</span></div><div class="line">	skb_dst_set(skb, &amp;rt-&gt;dst);</div><div class="line">	<span class="built_in">memset</span>(IPCB(skb), <span class="number">0</span>, <span class="keyword">sizeof</span>(*IPCB(skb)));</div><div class="line"></div><div class="line">	<span class="comment">/* Push down and install the IP header. */</span></div><div class="line">	<span class="comment">/*设置IP头部空间，并充值skb的L3头部指针*/</span></div><div class="line">	skb_push(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr));</div><div class="line">	skb_reset_network_header(skb);</div><div class="line">	<span class="comment">/*获取IP头部指针，并添加IP信息*/</span></div><div class="line">	iph = ip_hdr(skb);</div><div class="line"></div><div class="line">	iph-&gt;version	=	<span class="number">4</span>;</div><div class="line">	iph-&gt;ihl	=	<span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr) &gt;&gt; <span class="number">2</span>;</div><div class="line">	iph-&gt;frag_off	=	df;</div><div class="line">	iph-&gt;protocol	=	proto;</div><div class="line">	iph-&gt;tos	=	tos;</div><div class="line">	iph-&gt;daddr	=	dst;</div><div class="line">	iph-&gt;saddr	=	src;</div><div class="line">	iph-&gt;ttl	=	ttl;</div><div class="line">	__ip_select_ident(iph, skb_shinfo(skb)-&gt;gso_segs ?: <span class="number">1</span>);</div><div class="line">	<span class="comment">/*发送数据包*/</span></div><div class="line">	err = ip_local_out_sk(sk, skb);</div><div class="line">	<span class="keyword">if</span> (unlikely(net_xmit_eval(err)))</div><div class="line">		pkt_len = <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> pkt_len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>vxlan</code>类型接口调用<code>vxlan_tnl_send()</code>发送数据包时，会陆续的为数据包添加Vxlan头部信息、UDP头部信息、IP头部信息，完成数据包的封装过程，最后才调用<code>ip_local_out_sk()</code>函数将数据包发送出去。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LinuxKernel/" rel="tag">#LinuxKernel</a>
          
            <a href="/tags/Linux/" rel="tag">#Linux</a>
          
            <a href="/tags/OVS/" rel="tag">#OVS</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/24/OVS内核KEY值提取及匹配流表代码分析/" rel="next" title="OVS内核KEY值提取及匹配流表代码分析">
                <i class="fa fa-chevron-left"></i> OVS内核KEY值提取及匹配流表代码分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/25/OVS中端口数据包收发流程/"
           data-title="OVS中端口数据包收发流程" data-url="http://yoursite.com/2016/12/25/OVS中端口数据包收发流程/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="RY" />
          <p class="site-author-name" itemprop="name">RY</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenvSwitch"><span class="nav-number">1.</span> <span class="nav-text">OpenvSwitch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OVS上system类型接口收发包"><span class="nav-number">2.</span> <span class="nav-text">OVS上system类型接口收发包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#system类型接口接收数据包"><span class="nav-number">2.1.</span> <span class="nav-text">system类型接口接收数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system类型接口发送数据包"><span class="nav-number">2.2.</span> <span class="nav-text">system类型接口发送数据包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OVS中internal类型接口收发包"><span class="nav-number">3.</span> <span class="nav-text">OVS中internal类型接口收发包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#internal类型接口发送数据包"><span class="nav-number">3.1.</span> <span class="nav-text">internal类型接口发送数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#internal类型接口接收数据包"><span class="nav-number">3.2.</span> <span class="nav-text">internal类型接口接收数据包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OVS中VXLAN接口收发数据包"><span class="nav-number">4.</span> <span class="nav-text">OVS中VXLAN接口收发数据包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vxlan类型接口接收数据包"><span class="nav-number">4.1.</span> <span class="nav-text">vxlan类型接口接收数据包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vxlan类型接口发送数据包"><span class="nav-number">4.2.</span> <span class="nav-text">vxlan类型接口发送数据包</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RY</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ry0117"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>
